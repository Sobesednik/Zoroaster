#!/usr/bin/env node
'use strict';

const fs = require('fs');
const path = require('path');
const TestSuite = require('../src/test_suite');
const lib = require('../src/lib');

function resolveTestPath(test) {
    return path.join(process.cwd(), test);
}

function buildDirectory(dir) {
    const content = fs.readdirSync(dir);
    const res = {};
    content.forEach((node) => {
        const nodePath = path.join(dir, node);
        const stat = fs.lstatSync(nodePath);
        if (stat.isFile()) {
            res[node] = resolveTestPath(nodePath);
        } else if (stat.isDirectory()) {
            res[node] = buildDirectory(nodePath);
        }
    });
    return res;
}

function parseArgv(argv) {
    const argvPath = resolveTestPath(argv);
    try {
        const res = fs.lstatSync(argvPath);
        if (res.isFile()) {
            return new TestSuite(argv, argvPath);
        } else if (res.isDirectory()) {
            const dir = buildDirectory(argv);
            return new TestSuite(argv, dir);
        }
    } catch (err) {
        // file or directory does not exist
        return undefined;
    }
    return undefined;
}

function resolveTestSuites(argv) {
    return argv
        .slice(2)
        // ignore flags
        .filter((argv) => {
            return !/^--/.test(argv);
        })
        // create test suites and remove paths that cannot be resolved
        .map(parseArgv)
        .filter(testSuite => testSuite !== undefined);
}

function watchFiles(files, callback) {
    files.forEach((file) => {
        // console.log(`Watching ${file} for changes...`);
        fs.watchFile(file, callback);
    });
}
function unwatchFiles(files) {
    files.forEach((file) => {
        // console.log(`Unwatching ${file}`);
        fs.unwatchFile(file);
    });
}
/**
 * Remove modules cached by require.
 */
function clearRequireCache() {
    Object.keys(require.cache).forEach((key) => {
        delete require.cache[key];
    });
}

function test(testSuites, watch, currentlyWatching) {
    clearRequireCache();
    testSuites.forEach(ts => ts.require());
    if (watch) {
        const cw = Array.isArray(currentlyWatching) ? currentlyWatching : [];
        unwatchFiles(cw);
        const newCurrentlyWatching = Object.keys(require.cache);
        watchFiles(newCurrentlyWatching, () => test(testSuites, watch, newCurrentlyWatching));
    }
    return lib.runInSequence(testSuites)
        .then((testSuites) => {
            // eslint-disable-next-line no-console
            console.log(new Date().toUTCString());
            // eslint-disable-next-line no-console
            testSuites.forEach((ts) => console.log(ts.dump()));
            const hasErrors = !testSuites.reduce((prev, ts) =>
                prev && !ts.hasErrors()
            , true);
            if (hasErrors && !watch) {
                process.exit(1);
            } else {
                // eslint-disable-next-line no-console
                console.log(); // add new line for readability
            }
        });
}

const watch = !!process.argv.find(arg => arg === '--watch');

const testSuites = resolveTestSuites(process.argv);
test(testSuites, watch);
